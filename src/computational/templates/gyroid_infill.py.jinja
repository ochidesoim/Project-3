"""
Generated by LumenOrb v2.0
Template: gyroid_infill
Intent: {{ intent }}
"""

import sys
from pathlib import Path
import math

try:
    import PicoGK as pk
except ImportError:
    print("ERROR: PicoGK not installed", file=sys.stderr)
    sys.exit(1)


def main():
    """Generate pure gyroid lattice structure"""
    
    # Parameters
    BOUNDING_X = {{ params.bounding_box_mm.x }}
    BOUNDING_Y = {{ params.bounding_box_mm.y }}
    BOUNDING_Z = {{ params.bounding_box_mm.z }}
    PERIOD = {{ params.period_mm }}
    THICKNESS = {{ params.thickness_mm }}
    VOXEL_SIZE = {{ params.voxel_size_mm }}
    
    print(f"Initializing PicoGK (voxel size: {VOXEL_SIZE}mm)")
    
    try:
        pk.Library.oViewer()
        pk.Library.fVoxelSizeMM = VOXEL_SIZE
        
        print(f"Creating gyroid lattice:")
        print(f"  Bounding box: {BOUNDING_X} x {BOUNDING_Y} x {BOUNDING_Z} mm")
        print(f"  Period: {PERIOD}mm, Thickness: {THICKNESS}mm")
        
        # Create lattice structure
        lat = pk.Lattice()
        
        # Generate gyroid-like pattern using interconnected beams
        # True gyroid requires implicit SDF evaluation
        # This is an approximation using a lattice network
        
        scale = 2 * math.pi / PERIOD
        step = PERIOD / 4  # Sample 4 points per period
        
        points = []
        
        # Sample gyroid surface points
        z = 0
        while z < BOUNDING_Z:
            y = 0
            while y < BOUNDING_Y:
                x = 0
                while x < BOUNDING_X:
                    # Gyroid implicit: sin(x)cos(y) + sin(y)cos(z) + sin(z)cos(x) = 0
                    # Find approximate surface points
                    gx = x * scale
                    gy = y * scale
                    gz = z * scale
                    
                    value = (
                        math.sin(gx) * math.cos(gy) +
                        math.sin(gy) * math.cos(gz) +
                        math.sin(gz) * math.cos(gx)
                    )
                    
                    # If near the surface (|value| < threshold), add a sphere
                    if abs(value) < 0.5:
                        points.append((x, y, z))
                        lat.AddSphere(
                            pk.Vector3(x, y, z),
                            THICKNESS,
                            THICKNESS
                        )
                    
                    x += step
                y += step
            z += step
        
        print(f"Generated {len(points)} lattice nodes")
        
        # Connect nearby nodes with beams
        print("Connecting nodes...")
        beam_count = 0
        connection_radius = PERIOD * 0.6
        
        for i, p1 in enumerate(points):
            for p2 in points[i+1:]:
                dx = p1[0] - p2[0]
                dy = p1[1] - p2[1]
                dz = p1[2] - p2[2]
                dist = math.sqrt(dx*dx + dy*dy + dz*dz)
                
                if dist < connection_radius:
                    lat.AddBeam(
                        pk.Vector3(p1[0], p1[1], p1[2]),
                        pk.Vector3(p2[0], p2[1], p2[2]),
                        THICKNESS * 0.5,
                        THICKNESS * 0.5,
                        True
                    )
                    beam_count += 1
        
        print(f"Created {beam_count} connecting beams")
        
        print("Converting to voxels...")
        voxels = pk.Voxels(lat)
        
        print("Running Marching Cubes...")
        mesh = pk.Mesh(voxels)
        
        output_file = Path("output.stl")
        print(f"Saving to {output_file}...")
        mesh.SaveToStlFile(str(output_file))
        
        print("SUCCESS: Gyroid lattice generated")
        
    except Exception as e:
        print(f"ERROR: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
