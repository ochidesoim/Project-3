"""
Generated by LumenOrb v2.0
Template: boolean_cut
Intent: {{ intent }}
"""

import sys
from pathlib import Path
import math

try:
    import PicoGK as pk
except ImportError:
    print("ERROR: PicoGK not installed", file=sys.stderr)
    sys.exit(1)


def main():
    """Perform boolean subtraction on existing geometry"""
    
    # Parameters
    BASE_MESH_PATH = r"{{ params.base_mesh_path }}"
    CUT_SHAPE = "{{ params.cut_shape }}"
    VOXEL_SIZE = {{ params.voxel_size_mm }}
    
    # Cut dimensions (shape-specific)
    {% for key, value in params.cut_dimensions.items() %}
    CUT_{{ key.upper() }} = {{ value }}
    {% endfor %}
    
    print(f"Initializing PicoGK (voxel size: {VOXEL_SIZE}mm)")
    
    try:
        pk.Library.oViewer()
        pk.Library.fVoxelSizeMM = VOXEL_SIZE
        
        # Load base mesh
        print(f"Loading base mesh: {BASE_MESH_PATH}")
        base_mesh = pk.Mesh.mshFromStlFile(BASE_MESH_PATH)
        base_voxels = pk.Voxels(base_mesh)
        
        # Create cut shape
        print(f"Creating {CUT_SHAPE} cut shape")
        cut_lat = pk.Lattice()
        
        {% if params.cut_shape == "sphere" %}
        # Sphere cut
        radius = CUT_RADIUS
        center_x = CUT_CENTER_X if 'CUT_CENTER_X' in dir() else 0
        center_y = CUT_CENTER_Y if 'CUT_CENTER_Y' in dir() else 0
        center_z = CUT_CENTER_Z if 'CUT_CENTER_Z' in dir() else 0
        
        cut_lat.AddSphere(
            pk.Vector3(center_x, center_y, center_z),
            radius,
            radius
        )
        
        {% elif params.cut_shape == "cylinder" %}
        # Cylinder cut
        radius = CUT_RADIUS
        height = CUT_HEIGHT
        center_x = CUT_CENTER_X if 'CUT_CENTER_X' in dir() else 0
        center_y = CUT_CENTER_Y if 'CUT_CENTER_Y' in dir() else 0
        center_z = CUT_CENTER_Z if 'CUT_CENTER_Z' in dir() else 0
        
        cut_lat.AddBeam(
            pk.Vector3(center_x, center_y, center_z),
            pk.Vector3(center_x, center_y, center_z + height),
            radius,
            radius,
            True
        )
        
        {% elif params.cut_shape == "box" %}
        # Box cut (approximated with multiple beams)
        width = CUT_WIDTH
        depth = CUT_DEPTH
        height = CUT_HEIGHT
        center_x = CUT_CENTER_X if 'CUT_CENTER_X' in dir() else 0
        center_y = CUT_CENTER_Y if 'CUT_CENTER_Y' in dir() else 0
        center_z = CUT_CENTER_Z if 'CUT_CENTER_Z' in dir() else 0
        
        # Create solid box using orthogonal beams
        beam_radius = min(width, depth, height) / 2
        
        for z in range(int(center_z), int(center_z + height), int(beam_radius)):
            for y in range(int(center_y - depth/2), int(center_y + depth/2), int(beam_radius)):
                cut_lat.AddBeam(
                    pk.Vector3(center_x - width/2, y, z),
                    pk.Vector3(center_x + width/2, y, z),
                    beam_radius,
                    beam_radius,
                    False
                )
        {% endif %}
        
        cut_voxels = pk.Voxels(cut_lat)
        
        # Perform boolean subtraction
        print("Performing boolean subtraction...")
        result_voxels = pk.Voxels.voxBoolSubtract(base_voxels, cut_voxels)
        
        print("Converting to mesh...")
        result_mesh = pk.Mesh(result_voxels)
        
        output_file = Path("output.stl")
        print(f"Saving to {output_file}...")
        result_mesh.SaveToStlFile(str(output_file))
        
        print("SUCCESS: Boolean cut completed")
        
    except FileNotFoundError:
        print(f"ERROR: Base mesh not found: {BASE_MESH_PATH}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"ERROR: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
