"""
Generated by LumenOrb v2.0
Template: shell_lattice_gyroid
Intent: {{ intent }}

Uses trimesh for geometry generation (PicoGK fallback)
"""

import sys
from pathlib import Path
import numpy as np

try:
    import trimesh
    from trimesh.creation import cylinder
except ImportError:
    print("ERROR: trimesh not installed", file=sys.stderr)
    sys.exit(1)


def create_gyroid_approximation(bounds, period, thickness, resolution=50):
    """
    Create a gyroid-like lattice structure using marching cubes
    
    The gyroid is defined by: sin(x)cos(y) + sin(y)cos(z) + sin(z)cos(x) = 0
    """
    import numpy as np
    from skimage import measure
    
    x = np.linspace(0, bounds[0], resolution)
    y = np.linspace(0, bounds[1], resolution)
    z = np.linspace(0, bounds[2], resolution)
    
    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')
    
    # Scale to period
    scale = 2 * np.pi / period
    
    # Gyroid implicit function
    gyroid = (
        np.sin(X * scale) * np.cos(Y * scale) +
        np.sin(Y * scale) * np.cos(Z * scale) +
        np.sin(Z * scale) * np.cos(X * scale)
    )
    
    # Create shell around gyroid surface
    gyroid_shell = np.abs(gyroid) - thickness
    
    # Extract isosurface using marching cubes
    try:
        verts, faces, normals, values = measure.marching_cubes(
            gyroid_shell, 
            level=0,
            spacing=(bounds[0]/resolution, bounds[1]/resolution, bounds[2]/resolution)
        )
        return trimesh.Trimesh(vertices=verts, faces=faces)
    except:
        # Fallback to simple lattice if marching cubes fails
        return None


def main():
    """Generate shell with gyroid lattice infill"""
    
    # Parameters
    OUTER_RADIUS = {{ params.outer_radius_mm }}
    WALL_THICKNESS = {{ params.wall_thickness_mm }}
    LATTICE_PERIOD = {{ params.lattice_period_mm }}
    LATTICE_THICKNESS = {{ params.lattice_thickness_mm }}
    
    INNER_RADIUS = OUTER_RADIUS - WALL_THICKNESS
    HEIGHT = OUTER_RADIUS * 2  # Default height = diameter
    
    print(f"Creating shell with gyroid infill:")
    print(f"  Outer radius: {OUTER_RADIUS}mm")
    print(f"  Wall thickness: {WALL_THICKNESS}mm")
    print(f"  Lattice period: {LATTICE_PERIOD}mm")
    
    try:
        # Create outer cylinder
        print("Creating outer cylinder...")
        outer = cylinder(radius=OUTER_RADIUS, height=HEIGHT, sections=64)
        outer.apply_translation([0, 0, HEIGHT / 2])
        
        # Create inner cylinder (for hollowing)
        print("Creating inner void...")
        inner = cylinder(radius=INNER_RADIUS, height=HEIGHT + 2, sections=64)
        inner.apply_translation([0, 0, HEIGHT / 2])
        
        # Boolean subtraction to create shell
        print("Performing boolean subtraction...")
        shell = outer.difference(inner)
        
        if shell is None or len(shell.vertices) == 0:
            print("Warning: Boolean failed, using outer cylinder only")
            shell = outer
        
        # Try to add gyroid infill
        try:
            print("Generating gyroid lattice (this may take a moment)...")
            from skimage import measure
            
            # Create gyroid in bounding box
            bounds = [INNER_RADIUS * 2, INNER_RADIUS * 2, HEIGHT]
            gyroid = create_gyroid_approximation(
                bounds, 
                LATTICE_PERIOD, 
                LATTICE_THICKNESS,
                resolution=30
            )
            
            if gyroid is not None:
                # Center gyroid
                gyroid.apply_translation([-INNER_RADIUS, -INNER_RADIUS, 0])
                
                # Clip to inner cylinder
                inner_clip = cylinder(radius=INNER_RADIUS - 0.1, height=HEIGHT, sections=64)
                inner_clip.apply_translation([0, 0, HEIGHT / 2])
                
                gyroid_clipped = gyroid.intersection(inner_clip)
                
                if gyroid_clipped is not None and len(gyroid_clipped.vertices) > 0:
                    # Combine shell and gyroid
                    final_mesh = trimesh.util.concatenate([shell, gyroid_clipped])
                    print(f"[OK] Generated shell + gyroid with {len(final_mesh.vertices)} vertices")
                else:
                    final_mesh = shell
                    print("Using shell only (gyroid clipping failed)")
            else:
                final_mesh = shell
                print("Using shell only (gyroid generation failed)")
                
        except ImportError:
            print("Note: scikit-image not installed, skipping gyroid infill")
            print("Install with: pip install scikit-image")
            final_mesh = shell
        
        # Output
        output_file = Path("output.stl")
        print(f"Saving to {output_file}...")
        final_mesh.export(str(output_file))
        
        print(f"SUCCESS: Shell generated")
        
    except Exception as e:
        print(f"ERROR: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
