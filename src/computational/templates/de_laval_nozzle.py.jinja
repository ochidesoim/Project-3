"""
Generated by LumenOrb v2.0
Template: de_laval_nozzle
Intent: {{ intent }}

Creates a De Laval (converging-diverging) rocket nozzle with optional structural flange
"""

import sys
from pathlib import Path
import numpy as np

try:
    import trimesh
    from trimesh.creation import cylinder
except ImportError:
    print("ERROR: trimesh not installed. Run: pip install trimesh", file=sys.stderr)
    sys.exit(1)


def create_nozzle_profile(
    chamber_radius_mm,
    throat_radius_mm,
    exit_radius_mm,
    converging_length_mm,
    diverging_length_mm,
    n_points=100
):
    """
    Create a 2D profile for De Laval nozzle (r-z coordinates)
    Returns array of [r, z] points
    """
    points = []
    
    # Converging section (chamber to throat)
    z_conv = np.linspace(0, converging_length_mm, n_points // 2)
    # Use a smooth curve (cosine interpolation) for converging section
    for z in z_conv:
        t = z / converging_length_mm  # 0 to 1
        # Smooth transition using cosine interpolation
        r = chamber_radius_mm - (chamber_radius_mm - throat_radius_mm) * (1 - np.cos(t * np.pi / 2))
        points.append([r, z])
    
    # Diverging section (throat to exit)
    z_div = np.linspace(converging_length_mm, converging_length_mm + diverging_length_mm, n_points // 2)
    # Use a smooth expansion curve (sine interpolation) for diverging section
    for z in z_div:
        t = (z - converging_length_mm) / diverging_length_mm  # 0 to 1
        # Smooth expansion using sine interpolation
        r = throat_radius_mm + (exit_radius_mm - throat_radius_mm) * np.sin(t * np.pi / 2)
        points.append([r, z])
    
    return np.array(points)


def create_lattice_flange(radius_mm, thickness_mm, height_mm, lattice_period_mm, lattice_thickness_mm):
    """
    Create a structural lattice flange (ring with lattice infill)
    """
    try:
        from skimage import measure
        
        # Create outer ring
        outer_ring = cylinder(radius=radius_mm, height=height_mm, sections=64)
        outer_ring.apply_translation([0, 0, height_mm / 2])
        
        # Create inner void
        inner_radius = radius_mm - thickness_mm
        inner_ring = cylinder(radius=inner_radius, height=height_mm + 2, sections=64)
        inner_ring.apply_translation([0, 0, height_mm / 2])
        
        # Create shell
        shell = outer_ring.difference(inner_ring)
        if shell is None or len(shell.vertices) == 0:
            return None
        
        # Create simple radial lattice pattern
        lattice_meshes = []
        n_radial = int(2 * np.pi * radius_mm / lattice_period_mm)
        n_axial = max(1, int(height_mm / lattice_period_mm))
        
        for i in range(n_radial):
            angle = 2 * np.pi * i / n_radial
            for j in range(n_axial):
                z = (j + 0.5) * height_mm / n_axial
                r = inner_radius + thickness_mm / 2
                x = r * np.cos(angle)
                y = r * np.sin(angle)
                
                # Create small sphere at lattice point
                sphere = trimesh.creation.icosphere(subdivisions=1, radius=lattice_thickness_mm / 2)
                sphere.apply_translation([x, y, z])
                lattice_meshes.append(sphere)
        
        if lattice_meshes:
            lattice = trimesh.util.concatenate(lattice_meshes)
            # Clip lattice to shell interior
            inner_clip = cylinder(radius=inner_radius + 0.1, height=height_mm, sections=64)
            inner_clip.apply_translation([0, 0, height_mm / 2])
            lattice_clipped = lattice.intersection(inner_clip)
            
            if lattice_clipped is not None and len(lattice_clipped.vertices) > 0:
                return trimesh.util.concatenate([shell, lattice_clipped])
        
        return shell
        
    except Exception as e:
        print(f"Warning: Could not create lattice flange: {e}")
        # Fallback to simple ring
        outer = cylinder(radius=radius_mm, height=height_mm, sections=64)
        outer.apply_translation([0, 0, height_mm / 2])
        inner = cylinder(radius=radius_mm - thickness_mm, height=height_mm + 2, sections=64)
        inner.apply_translation([0, 0, height_mm / 2])
        shell = outer.difference(inner)
        return shell if shell is not None and len(shell.vertices) > 0 else None


def main():
    """Generate De Laval nozzle geometry"""
    
    # Parameters
    CHAMBER_RADIUS_MM = {{ params.chamber_radius_mm }}
    THROAT_RADIUS_MM = {{ params.throat_radius_mm }}
    EXIT_RADIUS_MM = {{ params.exit_radius_mm }}
    WALL_THICKNESS_MM = {{ params.wall_thickness_mm }}
    CONVERGING_LENGTH_MM = {{ params.converging_length_mm }}
    DIVERGING_LENGTH_MM = {{ params.diverging_length_mm }}
    ADD_FLANGE = {{ params.add_flange }}
    {% if params.add_flange %}
    FLANGE_RADIUS_MM = {{ params.flange_radius_mm }}
    FLANGE_HEIGHT_MM = {{ params.flange_height_mm }}
    FLANGE_LATTICE_PERIOD_MM = {{ params.flange_lattice_period_mm }}
    FLANGE_LATTICE_THICKNESS_MM = {{ params.flange_lattice_thickness_mm }}
    {% else %}
    FLANGE_RADIUS_MM = None
    FLANGE_HEIGHT_MM = None
    FLANGE_LATTICE_PERIOD_MM = 5.0
    FLANGE_LATTICE_THICKNESS_MM = 0.5
    {% endif %}
    
    print(f"Creating De Laval nozzle:")
    print(f"  Chamber radius: {CHAMBER_RADIUS_MM}mm")
    print(f"  Throat radius: {THROAT_RADIUS_MM}mm")
    print(f"  Exit radius: {EXIT_RADIUS_MM}mm")
    print(f"  Wall thickness: {WALL_THICKNESS_MM}mm")
    print(f"  Converging length: {CONVERGING_LENGTH_MM}mm")
    print(f"  Diverging length: {DIVERGING_LENGTH_MM}mm")
    
    try:
        # Create nozzle by stacking multiple cylinders with varying radii
        # This is more reliable than trying to use trimesh's revolve function
        print("Creating nozzle profile...")
        profile = create_nozzle_profile(
            CHAMBER_RADIUS_MM,
            THROAT_RADIUS_MM,
            EXIT_RADIUS_MM,
            CONVERGING_LENGTH_MM,
            DIVERGING_LENGTH_MM,
            n_points=50
        )
        
        total_length = CONVERGING_LENGTH_MM + DIVERGING_LENGTH_MM
        n_segments = len(profile) - 1
        
        print(f"Building nozzle from {n_segments} segments...")
        nozzle_segments = []
        
        for i in range(n_segments):
            z1, r1_inner = profile[i][1], profile[i][0]
            z2, r2_inner = profile[i+1][1], profile[i+1][0]
            
            r1_outer = r1_inner + WALL_THICKNESS_MM
            r2_outer = r2_inner + WALL_THICKNESS_MM
            
            segment_height = z2 - z1
            if segment_height < 0.1:
                continue
            
            # Create outer frustum (truncated cone)
            # Use average radius for cylinder approximation
            r_outer_avg = (r1_outer + r2_outer) / 2
            r_inner_avg = (r1_inner + r2_inner) / 2
            
            # Create outer cylinder
            outer_cyl = cylinder(radius=r_outer_avg, height=segment_height, sections=64)
            outer_cyl.apply_translation([0, 0, z1 + segment_height / 2])
            
            # Create inner void
            inner_cyl = cylinder(radius=r_inner_avg, height=segment_height + 1, sections=64)
            inner_cyl.apply_translation([0, 0, z1 + segment_height / 2])
            
            # Create segment shell
            segment = outer_cyl.difference(inner_cyl)
            if segment is not None and len(segment.vertices) > 0:
                nozzle_segments.append(segment)
        
        if not nozzle_segments:
            raise ValueError("Failed to create any nozzle segments")
        
        print("Combining nozzle segments...")
        nozzle_shell = trimesh.util.concatenate(nozzle_segments)
        
        if nozzle_shell is None or len(nozzle_shell.vertices) == 0:
            raise ValueError("Failed to create nozzle shell")
        
        # Add flange at throat if requested
        if ADD_FLANGE:
            print(f"Adding structural lattice flange at throat...")
            flange = create_lattice_flange(
                FLANGE_RADIUS_MM,
                WALL_THICKNESS_MM,
                FLANGE_HEIGHT_MM,
                FLANGE_LATTICE_PERIOD_MM,
                FLANGE_LATTICE_THICKNESS_MM
            )
            
            if flange is not None:
                # Position flange at throat
                flange.apply_translation([0, 0, CONVERGING_LENGTH_MM - FLANGE_HEIGHT_MM / 2])
                nozzle_shell = trimesh.util.concatenate([nozzle_shell, flange])
                print("[OK] Flange added")
            else:
                print("Warning: Could not create flange")
        
        # Ensure mesh is watertight
        if not nozzle_shell.is_watertight:
            print("Warning: Mesh is not watertight, attempting repair...")
            nozzle_shell.fill_holes()
            nozzle_shell.remove_duplicate_faces()
            nozzle_shell.remove_unreferenced_vertices()
        
        print(f"Generated nozzle with {len(nozzle_shell.vertices)} vertices, {len(nozzle_shell.faces)} faces")
        
        if nozzle_shell.is_watertight:
            print("[OK] Mesh is watertight (manifold)")
        else:
            print("[WARN] Warning: Mesh may not be watertight")
        
        # Output
        output_file = Path("output.stl")
        print(f"Saving to {output_file}...")
        nozzle_shell.export(str(output_file))
        
        print(f"SUCCESS: De Laval nozzle generated at {output_file}")
        
    except Exception as e:
        print(f"ERROR: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()

